<template>
<div class="internal-page">
  <div class="green-cover" v-bind:class="{ 'green-cover__full-page': secondReview }">
    <div class="row green-cover__head">
      <div class="col-md-2 col-sm-1">
        <router-link to="/dashboard">
          <div class="logo">
            <img src="../assets/img/logo-white.svg" alt="">
          </div>
        </router-link>
      </div>
      <counterRatio v-if="initialFetchComplete" :initialDenominator="reviewDeck.words.length"></counterRatio>
    </div>
    <transition name="modal">
      <completeModal v-if="showCompleteModal" v-bind:words ="reviewDeck.words" @close="showCompleteModal = false">
      </completeModal>
    </transition>
    <transition name="modal">
      <messageModal v-show="showMessage" @close="showMessage = false">
        <span slot="body">
          Awesome, now review the words one more time without any hints!
        </span>
      </messageModal>
    </transition>
    <div class="container green-cover__body">
      <div class="row ">
        <div class="col-md-offset-2 col-md-8">
         <card v-if="initialFetchComplete" v-bind:words="reviewDeck" v-bind:deck="true"></card>
        </div>
      </div>
    </div>
  </div>
  <div v-if="!secondReview && initialFetchComplete" class="lesson">
    <div class="row">
      <div class="col-md-4">
        <p class="red-title">Basics</p>
        <div class="row lesson__row">
          <div class="col-md-3">
            <p class="gray-title">Reading:</p>
          </div>
          <div class="col-md-9">
            <p class="simple-text">{{ currentWord.hiragana }}</p>
          </div>
        </div>
        <div class="row lesson__row">
          <div class="col-md-3">
            <p class="gray-title">POS:</p>
          </div>
            <p class="simple-text">{{ partOfSpeech }}</p>
        </div>
        <div class="row lesson__row">
          <div class="col-md-3">
            <p class="gray-title">Kanji:</p>
          </div>
          <div v-for="kanji in currentWord.kanji" class="col-md-3">
            <div class="panel text-center">
              {{ kanji.kanji_name }} 
              <p class="gray-title">
                {{ kanji.kanji_meaning }}
              </p>
            </div>
          </div>
        </div>
      </div>
      <div class="col-md-4 lesson__center">
        <p class="red-title">Details</p>
        <p class="gray-title">Meanings:</p>
        <p class="simple-text">{{ meaningsText }}</p><br>
        <p class="gray-title">Sentences:</p><br>
          <div v-for="(sentence, index) in currentWord.sentence">
            <p class="simple-text">{{ index + 1 }}. {{ sentence.japanese_sentence }}</p>
            <p class="simple-text">{{ sentence.english_sentence }}</p>
            <br>
          </div>
      </div>
      <div class="col-md-4">
        <p class="red-title">The good stuff</p>
        <p class="lesson__question">When most frequently heard?</p>
        <p class="simple-text">Fusce vehicula dolor arcu, sit amet blandit dolor mollis nec.</p><br>
        <p class="lesson__question">When not to use?</p>
        <p class="simple-text">Fusce vehicula dolor arcu, sit amet blandit dolor mollis nec.</p>
      </div>
 
    </div>
  </div>
</div>
</template>

<script>
import auth from '../auth'
import helper from '../helpers'
import Card from '../components/Card.vue'
import counterRatio from '../components/counterRatio.vue'
import completeModal from '../components/deckReviewCompleteModal.vue'
import baseModal from '../components/modalBase.vue'
export default {
  name: 'me',
  data () {
    return {
      initialFetchComplete: false,
      deckId: '',
      msg: 'The route works',
      reviewDeck: [],
      reviewDeckLength: 5,
      reviewDeckOriginal: [],
      currentCardIndex: 0,
      currentWord: '',
      secondReview: false,
      showCompleteModal: false,
      showMessage: false,
      errors: null
    }
  },
  components: {
    'card': Card,
    'counterRatio': counterRatio,
    'completeModal': completeModal,
    'messageModal': baseModal
  },
  head: {
    title: function () {
      return {
        inner: 'kanjisama',
        complement: 'review'
      }
    }
  },
  created () {
    this.getReviewDeck()
    window.eventHub.$on('completeCard', this.completeCard)
    window.eventHub.$on('deckComplete', this.deckComplete)
  },
  beforeDestroy () {
    window.eventHub.$off('completeCard', this.completeCard)
    window.eventHub.$off('deckComplete', this.deckComplete)
  },
  methods: {
    getReviewDeck () {
      var level = this.$route.params.lvl
      var sublevel = this.$route.params.sublevel
      var url = '/api/review/lvl-' + level + '/' + sublevel + '/get'
      this.$http.get(url, {headers: auth.getAuthHeader()})
      .then(response => {
        this.errors = null
        this.reviewDeck = response.data[0]
        this.reviewDeckOriginal = response.data[0]
        this.deckId = this.reviewDeck.id
        this.setCurrentWord(this.currentCardIndex)
        this.initialFetchComplete = true
      }, error => {
        if (error) {
          this.errors = 'Could not fetch deck from server!'
          this.initialFetchComplete = true
        }
      })
    },
    completeCard: function (arrayIndex, bothCorrect) {
      console.log(this.reviewDeckOriginal.words)
      if (bothCorrect) {
        window.eventHub.$emit('increment')
      } else {
        this.reviewDeck.words.push(this.reviewDeck.words[arrayIndex])
      }
      if (this.reviewDeck.words.length !== arrayIndex + 1) {
        this.currentCardIndex = arrayIndex + 1
        this.setCurrentWord(this.currentCardIndex)
      }
    },
    postStackComplete () {
      var url = '/api/review/review-deck-complete'
      this.$http.post(url, {'stack_id': this.deckId}, {headers: auth.getAuthHeader()})
      .then(response => {
        this.showCompleteModal = true
      }, error => {
        if (error) {
          this.errors = 'Oh no! Something went wrong and we couldn\t save your words!'
        }
      })
    },
    deckComplete: function () {
      if (this.secondReview) {
        this.postStackComplete()
      } else {
        window.eventHub.$emit('reset')
        this.currentCardIndex = 0
        this.setCurrentWord(this.currentCardIndex)
        let incorrectCount = this.reviewDeckLength - this.reviewDeck.words.length
        if (incorrectCount > 0) {
          this.reviewDeck.words.splice(incorrectCount)
        }
        this.secondReview = true
        this.showMessage = true
      }
    },
    setCurrentWord: function (currentIndex) {
      this.currentWord = this.reviewDeck.words[currentIndex]
    }
  },
  computed: {
    // look into returning pos as array of strings from api vs object with pos property
    partOfSpeech: function () {
      var arrayPos = []
      this.currentWord.pos.forEach(function (object) {
        arrayPos.push(object.pos)
      })
      return helper.arrayToCommaSeperatedString(arrayPos)
    },
    meaningsText: function () {
      var arrayPos = []
      this.currentWord.meanings.forEach(function (object) {
        arrayPos.push(object.meaning)
      })
      // return 'weee'
      return helper.arrayToCommaSeperatedString(arrayPos)
    }
  }
}
</script>

<!-- Add "scoped" attribute to limit CSS to this component only -->
<style lang="scss" scoped>
</style>
